/**
 * Turns gregtech worldgen into excavator scripts
 * 
 * Expects:
 * - The config/gregtech/worldgen directory
 * - items.csv: Generated by /tellme dump-csv
 * - A directory 'excavatorOut' to write to
 * 
 * Outputs:
 * - One 'Excavator{dimension}.zs file per dim
 */

// Imports
const csv = require('csv-parser');
const fs = require('fs');
const _ = require('lodash');

const oredict = require('./oreDictionary');
const worldgen = require('./worldgen');
const util = require('./util');

// Outputs
const dims = worldgen.dimensionConfig;
const items = [];

function oreToOreDict(ore, dim) {
    if (ore.startsWith('special:')) return ore.substr(8);
    return "oreGtExcavator" + util.gregOreToOreDict(ore) + _.upperFirst(dim);
}

module.exports = {
    create: () => {
        return new Promise((resolve) => {
            fs
                .createReadStream('items.csv')
                .pipe(csv())
                .on('data', (data) => {
                    items[`${data["Registry name"]}:${data["Meta/dmg"]}`] = data["Display name"];
                })
                .on('end', () => {
                    resolve();
                });
        }).then(() => new Promise((resolve) => {
            const oreNodes = _.cloneDeep(worldgen.oreNodes)

            // - Fluids
            // - Instances where the result is a single block (granite, esp)
            // - Anything that's not weight_random, but that's currently the only one in use
            const oresByDim = _
                .chain(oreNodes)
                .groupBy((n) => n.dimension)
                .mapValues((ores, idx) => {
                    return {
                        "filler": _.map(dims[idx].filler, (f, i) => `oreDict.oreGtExcavatorFiller${idx}${i}.add(<${f.block}>);`),
                        "ores": _
                            .chain(ores)
                            .flatMap((o) => {
                                return _.map(o.filler, (oi) => oi.ore);
                            })
                            .uniq()
                            .map((o) => {
                                if (o.startsWith('ore_dict:')) {
                                    return `oreDict.${oreToOreDict(o, idx)}.addAll(<ore:${o.substr(9)}>);`;
                                }

                                let ore;
                                if (o.startsWith('ore:')) ore =  `gregtech:${o.replace(":","_")}_0:${dims[idx].meta}`;
                                else if (o.startsWith('special:')) ore = _.first(worldgen.specialOres[o.substr(8)].values).value.substr(6);

                                return `oreDict.${oreToOreDict(o, idx)}.add(<${ore}>);`;
                            })
                            .filter((l) => l)
                            .sortBy((l) => l.includes('addAll') + l)
                            .value(),
                        "minerals": ores.map((o) => {
                            // Calculate all the things...
                            const oreDensity = _.clamp(o.density, 0, 1);
                            const oreItems = _.map(o.filler, (oi) => oreToOreDict(oi.ore, idx));
                            const totalWeight = _.sumBy(o.filler, (oi) => parseInt(oi.weight));
                            const oreWeights = _.map(o.filler, (oi) => _.round((oi.weight / totalWeight) * oreDensity, 4));

                            // Filler!
                            const fillerDensity = 1 - oreDensity;
                            if (0 < fillerDensity) {
                                _.each(dims[idx].filler, (f, i) => {
                                    oreItems.push(`oreGtExcavatorFiller${idx}${i}`);
                                    oreWeights.push(_.round(f.weight * fillerDensity, 4));
                                });
                            }

                            let topOre = _.maxBy(o.filler, (oi) => parseInt(oi.weight)).ore;
                            if (topOre.startsWith('special:')) {
                                topOre = _.first(worldgen.specialOres[topOre.substr(8)].values).value.substr(6);
                            } else {
                                let oreDictName = util.gregOreToOreDict(topOre);
                                topOre = oredict.resolveOredict('ore' + oreDictName);
                                if (!topOre) topOre = oreDictName;
                                else if (topOre.startsWith("gregtech")) topOre.replace(':0', ':' + dims[idx].meta);
                            }

                            // Convoluted way of figuring out what the name of the vein should be:
                            const mainOre = (items[topOre] || _.startCase(topOre.includes(':') ? topOre.split(':')[1] : topOre)).replace(' Ore','').trim();

                            if (oreItems.length != oreWeights.length) {
                                console.log(`Unable to match all ore entries in ${o.dimension}:${o.name}:`, o);
                            }

                            return `mods.immersiveengineering.Excavator.addMineral("${mainOre}", ${o.weight}` +
                                    `, 0.005, ["${oreItems.join('", "')}"], [${oreWeights.join(',')}], [${dims[o.dimension].id}]);`
                        })
                    }
                })
                .value();

            _.each(oresByDim, (data, idx) => {
                fs.writeFileSync(`../scripts/Excavator${_.upperFirst(idx)}.zs`, _.flatMap([
                    ['import crafttweaker.oredict.IOreDictEntry;','\n','// Ore dicts'],
                    data.ores,
                    ['\n', '// Filler ore dicts'],
                    data.filler,
                    ['\n','// Dig that hole'],
                    data.minerals
                ]).join('\n'));
            });

            resolve(oresByDim);
        }));
    }
}
